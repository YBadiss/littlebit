import hashlib
import hmac

import attr

from .field_element import FieldElement
from .point import Point

# secp256k1 elliptic curve equation: y² = x³ + 7

# Elliptic curve parameters A and B of the curve : y² = x³ Ax + B
A = 0
B = 7

# Prime of the finite field
P = 2 ** 256 - 2 ** 32 - 977


class S256FieldElement(FieldElement):
    def __init__(self, number, prime=None):
        super().__init__(number=number, prime=P)

    def __repr__(self):
        return f"{self.number:x}".zfill(64)


class S256Point(Point):
    def __init__(self, x, y, a=None, b=None):
        a, b = S256FieldElement(A), S256FieldElement(B)

        if isinstance(x, int) and isinstance(y, int):
            super().__init__(x=S256FieldElement(x), y=S256FieldElement(y), a=a, b=b)
        else:
            # x and y are either both None, or both instances of S256FieldElement
            super().__init__(x=x, y=y, a=a, b=b)

    def __rmul__(self, coefficient):
        return super().__rmul__(coefficient % N)

    def verify(self, z, signature):
        s_inv = pow(signature.s, N - 2, N)
        u = (z * s_inv) % N
        v = (signature.r * s_inv) % N

        total = u * G + v * self
        return total.x.number == signature.r


# Generator point
G = S256Point(
    x=0x79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798,
    y=0x483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8,
)

# Order of the Group generated by G, such that nG = I
N = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141


@attr.s
class Signature:
    r = attr.ib()
    s = attr.ib()

    def __repr__(self):
        return f"Signature(r={self.r:x}, s={self.s:x})"


@attr.s
class PrivateKey:
    secret = attr.ib()
    point = attr.ib(init=False)  # public key

    @point.default
    def init_point(self):
        return self.secret * G

    def hex(self):
        return f"{self.secret:x}".zfill(64)

    def sign(self, z):
        k = self.deterministic_k(z)  # or, randint(0, N)
        R = k * G
        r = R.x.number
        k_inv = pow(k, N - 2, N)
        s = ((z + r * self.secret) * k_inv) % N
        if s > N / 2:
            s = N - s
        return Signature(r, s)

    def deterministic_k(self, z):
        k = b"\x00" * 32
        v = b"\x01" * 32
        if z > N:
            z -= N
        z_bytes = z.to_bytes(32, "big")
        secret_bytes = self.secret.to_bytes(32, "big")
        s256 = hashlib.sha256
        k = hmac.new(k, v + b"\x00" + secret_bytes + z_bytes, s256).digest()
        v = hmac.new(k, v, s256).digest()
        k = hmac.new(k, v + b"\x01" + secret_bytes + z_bytes, s256).digest()
        v = hmac.new(k, v, s256).digest()
        while True:
            v = hmac.new(k, v, s256).digest()
            candidate = int.from_bytes(v, "big")
            if candidate >= 1 and candidate < N:
                return candidate  # <2>
            k = hmac.new(k, v + b"\x00", s256).digest()
            v = hmac.new(k, v, s256).digest()
